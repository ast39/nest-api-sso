# SSO Сервис

<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="200" alt="Nest Logo" /></a>
</p>

## Описание

SSO (Single Sign-On) - Микросервис для аутентификации и авторизации.

### Основные возможности

- ✅ Авторизация и аутентификация
- ✅ Пролонгация токена авторизации
- ✅ Возможность logout-а
- ✅ Настраиваемая защита от брутфорса
- ✅ Система блокировки токенов
- ✅ Настраиваемая ролевая система
- ✅ Рутовый пользователь
- ✅ Управление пользователями
- ✅ Система логирования
- ✅ Swagger документация
- ✅ Валидация токенов для сервисов экосистемы

## Установка и запуск

### Предварительные требования

- Node.js
- PostgreSQL
- Redis
- Yarn

### Установка

```bash
# Установка пакетов
yarn install

# Выполнение миграций
yarn prisma migrate deploy

# Выполнение сидеров
yarn prisma db seed

# Копирование шаблона для env настроек проекта 
cp .env.example .env
```

### Управление Prisma ORM

```bash
# Создание миграции
yarn prisma migrate dev --name init

# Обновление Prisma Client по схеме  
yarn prisma generate

# Обновление базы данных по файлам миграции в режиме разработки
yarn prisma migrate dev

# Устранение проблем с миграциями базы данных
yarn prisma migrate resolve

# Обновление базы данных по неисполненным миграциям в прод. режиме
yarn prisma migrate deploy

# Запуск сидов, заполняющих таблицы тестовыми данными
yarn prisma db seed
```

### Запуск приложения

```bash
# В режиме разработки
yarn start:dev

# В продакшн режиме
yarn start:prod
```

## Ролевая система

```typescript
// Доступ только по JWT токену 
// Вешается как на метод, так и на весь контроллер
@UseGuards(JwtAuthGuard)

// Доступ только рутовой учетке
// Вешается как на метод, так и на весь контроллер
@UseGuards(IsRootGuard)

// Доступ только учетке с указанными правами (одними из указанных)
// Вешается как на метод, так и на весь контроллер
@Roles('finance,hr')
```

## Алгоритм SSO-авторизации

### 1. Попытка входа на сайт

- Проверяется наличие и валидность JWT-токена
- Если токен валиден — пользователь авторизован
- Если токен невалиден или отсутствует — переход к SSO

### 2. Проверка sessionId

- Если sessionId есть (например, в httpOnly cookie):
  - Запрос к SSO: `/auth/session/login` с sessionId
  - Если сессия валидна:
    - Получаем пользователя
    - Генерируем новый JWT-токен
    - Обновляем TTL сессии
    - Возвращаем токен фронту
  - Если сессия не найдена или истекла:
    - Удаляем sessionId
    - Переходим к классической авторизации
- Если sessionId нет — переход к классической авторизации

### 3. Классическая авторизация (логин/пароль)

- Пользователь вводит логин и пароль
- Запрос к SSO: `/auth/login`
- Если данные верны:
  - Получаем пользователя
  - Создаём новую сессию в Redis (sessionId)
  - Генерируем JWT-токен
  - Устанавливаем sessionId в httpOnly cookie
  - Возвращаем токен фронту
- Если данные неверны — 401 Unauthorized

### 4. Работа сессии и токена

- При каждом запросе к защищённому ресурсу:
  - Проверяется токен
  - Если токен валиден — доступ разрешён
  - Если токен истёк — инициируется silent login через sessionId
- Silent login:
  - Если токен истёк, но есть sessionId — запрос на `/auth/session/login` для получения нового токена

### 5. Пролонгация сессии

- При каждом действии пользователя (клик, AJAX-запрос и т.д.):
  - Фронт вызывает `/auth/session/refresh` с sessionId
  - SSO обновляет TTL сессии в Redis
  - Это предотвращает автоматический логаут при активной работе пользователя

### 6. Логаут

- Фронт вызывает `/auth/logout` или `/auth/session/delete`
- SSO удаляет сессию из Redis
- Очищается sessionId (cookie/localStorage)
- Токен становится невалидным

### 7. Валидация токена для сервисов экосистемы

- Сервисы экосистемы отправляют запрос на `/auth/validate`:
  - JWT токен в заголовке `Authorization: Bearer <token>`
  - Опционально: `sessionId` в теле запроса
- SSO проверяет:
  - Не заблокирован ли токен
  - Валиден ли токен
  - Если токен валиден - возвращает информацию о пользователе (ID, логин, имя, отдел, должность, email, телефон, telegramId, роли, флаг root, ID сессии)
  - Если токен невалиден и передан `sessionId` - пытается выполнить silent login
  - Если silent login успешен - возвращает информацию о пользователе
  - Если все проверки не прошли - возвращает ошибку

Пример использования для сервисов экосистемы:
```typescript
// Пример запроса к SSO для валидации токена
const validateToken = async (token: string, sessionId?: string) => {
  const response = await fetch('http://sso-service/auth/validate', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ sessionId })
  });

  if (response.ok) {
    const userData = await response.json();
    // Получена информация о пользователе
    return userData;
  } else {
    // Токен невалиден и не удалось получить новый
    throw new Error('Unauthorized');
  }
};
```

## Edge cases и нюансы

- **Сессия истекла** — пользователь снова попадает на форму логина
- **Сессия удалена вручную (админом)** — при следующем запросе токен невалиден, silent login не сработает, потребуется логин/пароль
- **Мультидоменность** — если сайты на разных доменах, sessionId можно передавать через URL-параметры или использовать OAuth2 flow
- **Безопасность** — sessionId должен быть httpOnly и Secure, чтобы защититься от XSS и CSRF
- **Масштабируемость** — Redis позволяет хранить сессии централизованно для всех сервисов
- **Валидация токена** — сервисы экосистемы должны проверять токен через SSO, а не самостоятельно

## Краткое описание процесса

1. **Первый вход** — логин/пароль → sessionId + токен
2. **Дальше** — токен → если истёк, то sessionId → новый токен
3. **Сессия истекла** — снова логин/пароль
4. **Логаут** — удаление сессии и токена
5. **Мидлвар** — обновляет TTL сессии при активности
6. **Валидация** — сервисы проверяют токен через SSO

## Рекомендации

> **Важно:**  
> - Используйте httpOnly cookie для хранения sessionId на фронте
> - Когда есть централизованная сессия в Redis, refresh токены не используются
> - Все сервисы экосистемы должны проверять токены через SSO, а не самостоятельно
> - При получении ошибки валидации токена, сервисы должны перенаправлять на SSO для повторной авторизации

## Авторы

- Author - [ASt](https://github.com/ast39)
- Telegram - [@ASt39](https://t.me/ASt39)

## Лицензия

ASt